# axios封装
## 对于一个后端统一返回的格式
其实就是声明AxiosResponse.data的数据类型,并且声明其中的get,post 返回类型
```ts
/**
 * 基本数据类型
 */
export interface ResultResponse<T> {
  code: number;
  message: string;
  data: T;
}

/**
 * @template T 指定返回data的类型
 * Axios api返回类型
 */

export type ApiResultType<T> = Promise<AxiosResponse<ResultResponse<T>>>;

```

## 实现一个通用的ajax请求类
其中下载方法指定了返回数据为blob
```ts
/**
 * 网络请求对象
 */
export class Request {
  //axios实例对象
  private instance: AxiosInstance;
  // 请求基本地址
  private baseUrl: string;

  constructor(config: AxiosRequestConfig) {
    this.baseUrl = config.baseURL as string;
    this.instance = axios.create(config);

    //请求拦截器
    this.instance.interceptors.request.use(
      (config: InternalAxiosRequestConfig) => {
        return config;
      },
      (err: any) => {
        return Promise.reject(err);
      },
    );

    //响应拦截器
    this.instance.interceptors.response.use(
      (response: AxiosResponse<ResultResponse<any>>) => {
        response.data.code != undefined &&
          response.data.code != 2000 &&
          errorMessage(response.data.message);
        return response;
      },
      (err: any) => {
        return Promise.reject(err);
      },
    );
  }

  // 定义基本请求方法
  public request<T = any>(config: AxiosRequestConfig): ApiResultType<T> {
    return this.instance.request(config);
  }

  //get方法
  public get<T = any>(
    url: string,
    config?: AxiosRequestConfig,
  ): ApiResultType<T> {
    return this.instance.get(url, config);
  }

  //post方法
  public post<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): ApiResultType<T> {
    return this.instance.post(url, data, config);
  }

  //put方法
  public put<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig,
  ): ApiResultType<T> {
    return this.instance.put(url, data, config);
  }

  //delete方法
  public delete<T = any>(
    url: string,
    config?: AxiosRequestConfig,
  ): ApiResultType<T> {
    return this.instance.delete(url, config);
  }

  public download(url: string): Promise<AxiosResponse<Blob>> {
    return this.instance.get(url, {
      responseType: "blob",
    });
  }

  getBaseUrl(): string {
    return this.baseUrl;
  }
}
```

## 创建对象配置并且导出
其中 withCredentials跨域是否携带cookie
```ts
const request = new Request({
  baseURL: "http://localhost:" + import.meta.env.VITE_DEV_URL,
  timeout: 5*1000,
  headers: { "X-Custom-Header": "foobar" },
  withCredentials: true,
});

export default request;
```

## 使用

```ts
export namespace LoginApi {
    /**
     * 登录
     * @param loginForm
     */
    export function login(loginForm: LoginForm) {
        return request.post<BaseUserForm>("/login/check", loginForm);
    }
}


```

如果对于传入的泛型并没有返回他的全部属性我们推荐使用
```ts
type Partial<T> = {
[P in keyof T]?: T[P];
};
```
::: tip
这样就能通过指定泛型对api返回的数据进行类型约束了
:::
    


